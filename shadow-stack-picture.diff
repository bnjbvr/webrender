diff --git a/webrender/src/picture.rs b/webrender/src/picture.rs
index b0d7813b..8a4d7b15 100644
--- a/webrender/src/picture.rs
+++ b/webrender/src/picture.rs
@@ -3085,6 +3085,87 @@ impl PicturePrimitive {
 
                 PictureSurface::RenderTask(render_task_id)
             }
+            PictureCompositeMode::Filter(FilterOp::DropShadowStack(shadows)) => {
+                let mut max_std_deviation = 0.0;
+                let mut max_range = 0.0;
+                for shadow in &shadows {
+                    // TODO(nical) presumably we should compute the clipped rect for each shadow
+                    // and compute the union of them to determine what we need to rasterize and blur?
+                    max_std_deviation = f32::max(max_std_deviation, shadow.blur_radius * device_pixel_scale.0);
+                }
+
+                max_std_deviation = max_std_deviation.round();
+                let max_blur_range = (max_std_deviation * BLUR_SAMPLE_SCALE).ceil() as i32;
+                let mut device_rect = clipped.inflate(max_blur_range, max_blur_range)
+                        .intersection(&unclipped.to_i32())
+                        .unwrap();
+                device_rect.size = RenderTask::adjusted_blur_source_size(
+                    device_rect.size,
+                    DeviceSize::new(max_std_deviation, max_std_deviation),
+                );
+
+                let uv_rect_kind = calculate_uv_rect_kind(
+                    &pic_rect,
+                    &transform,
+                    &device_rect,
+                    device_pixel_scale,
+                    true,
+                );
+
+                let mut picture_task = RenderTask::new_picture(
+                    RenderTaskLocation::Dynamic(None, device_rect.size),
+                    unclipped.size,
+                    pic_index,
+                    device_rect.origin,
+                    child_tasks,
+                    uv_rect_kind,
+                    pic_context.raster_spatial_node_index,
+                    device_pixel_scale,
+                );
+                picture_task.mark_for_saving();
+
+                let picture_task_id = frame_state.render_tasks.add(picture_task);
+
+                self.secondary_render_task_id = Some(picture_task_id);
+
+                let blur_render_task = RenderTask::new_blur(
+                    rounded_std_dev,
+                    picture_task_id,
+                    frame_state.render_tasks,
+                    RenderTargetKind::Color,
+                    ClearMode::Transparent,
+                );
+
+                let render_task_id = frame_state.render_tasks.add(blur_render_task);
+                frame_state.surfaces[surface_index.0].tasks.push(render_task_id);
+
+                self.extra_gpu_data_handles.resize(shadows.len(), GpuCacheHandle::new());
+
+                for (shadow, extra_handle) in shadows.iter().zip(self.extra_gpu_data_handles.iter_mut()) {
+                    if let Some(mut request) = frame_state.gpu_cache.request(&mut extra_handle) {
+                        // Basic brush primitive header is (see end of prepare_prim_for_render_inner in prim_store.rs)
+                        //  [brush specific data]
+                        //  [segment_rect, segment data]
+                        let shadow_rect = self.local_rect.translate(&shadow.offset);
+
+                        // ImageBrush colors
+                        request.push(shadow.color.premultiplied());
+                        request.push(PremultipliedColorF::WHITE);
+                        request.push([
+                            self.local_rect.size.width,
+                            self.local_rect.size.height,
+                            0.0,
+                            0.0,
+                        ]);
+
+                        // segment rect / extra data
+                        request.push(shadow_rect);
+                        request.push([0.0, 0.0, 0.0, 0.0]);
+                    }
+                }
+
+                PictureSurface::RenderTask(render_task_id)
+            }
             PictureCompositeMode::Filter(ref filter) => {
                 if let FilterOp::ColorMatrix(m) = *filter {
                     if self.extra_gpu_data_handles.is_empty() {
diff --git a/webrender/src/render_task.rs b/webrender/src/render_task.rs
index 92891250..d671bd1f 100644
--- a/webrender/src/render_task.rs
+++ b/webrender/src/render_task.rs
@@ -427,6 +427,13 @@ pub enum ClearMode {
     Transparent,
 }
 
+#[derive(Copy, Clone, Debug, PartialEq, Hash)]
+pub enum BlurTaskKey {
+    DownScale(u32),
+    Blur(u32, f32),
+}
+pub type BlurTaskCache = FastHashMap<BlurTaskKey, RenderTaskId>;
+
 #[derive(Debug)]
 #[cfg_attr(feature = "capture", derive(Serialize))]
 #[cfg_attr(feature = "replay", derive(Deserialize))]
@@ -730,6 +737,7 @@ impl RenderTask {
         render_tasks: &mut RenderTaskTree,
         target_kind: RenderTargetKind,
         clear_mode: ClearMode,
+        blur_cache: Option<&mut BlurTaskCache>,
     ) -> Self {
         // Adjust large std deviation value.
         let mut adjusted_blur_std_deviation = blur_std_deviation;
@@ -740,6 +748,7 @@ impl RenderTask {
         let mut adjusted_blur_target_size = blur_target_size;
         let mut downscaling_src_task_id = src_task_id;
         let mut scale_factor = 1.0;
+        let mut level = 1;
         while adjusted_blur_std_deviation.width > MAX_BLUR_STD_DEVIATION &&
               adjusted_blur_std_deviation.height > MAX_BLUR_STD_DEVIATION {
             if adjusted_blur_target_size.width < MIN_DOWNSCALING_RT_SIZE ||
@@ -749,15 +758,30 @@ impl RenderTask {
             adjusted_blur_std_deviation = adjusted_blur_std_deviation * 0.5;
             scale_factor *= 2.0;
             adjusted_blur_target_size = (blur_target_size.to_f32() / scale_factor).to_i32();
-            let downscaling_task = RenderTask::new_scaling(
-                downscaling_src_task_id,
-                render_tasks,
-                target_kind,
-                adjusted_blur_target_size,
+
+            let downscaling_src_task_id = blur_cache.and_then(|cache| {
+                cache.get(&BlurTaskKey::DownScale(level))
+            }).or_else(|| {
+                let downscaling_task = RenderTask::new_scaling(
+                    downscaling_src_task_id,
+                    render_tasks,
+                    target_kind,
+                    adjusted_blur_target_size,
+                );
+                render_tasks.add(downscaling_task)
             );
-            downscaling_src_task_id = render_tasks.add(downscaling_task);
+
+            if let Some(cache) = blur_cache {
+                cache.insert(BlurTaskKey:;DownScale(level), downscaling_src_task_id);
+            }
+
+            level += 1;
         }
 
+        let blur_task_id = blur_cache.and_then(|cache| {
+            cache.get(&BlurTaskKey::Blur(level))
+        }).or_else(|| {
+
         let blur_task_v = RenderTask::with_dynamic_location(
             adjusted_blur_target_size,
             vec![downscaling_src_task_id],
